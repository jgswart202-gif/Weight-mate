import 'package:flutter/material.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(WeightTrackerApp());
}

class WeightEntry {
  final int? id;
  final double weight;
  final String date;

  WeightEntry({this.id, required this.weight, required this.date});

  Map<String, dynamic> toMap() => {
        'id': id,
        'weight': weight,
        'date': date,
      };
}

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._internal();
  DatabaseHelper._internal();

  Database? _db;

  Future<Database> get db async {
    if (_db != null) return _db!;
    _db = await _initDB('weights.db');
    return _db!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: 2,
      onCreate: (db, version) async {
        await db.execute('''CREATE TABLE weights(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            weight REAL,
            date TEXT)''');
        await db.execute('''CREATE TABLE settings(
            id INTEGER PRIMARY KEY,
            goal REAL)''');
      },
      onUpgrade: (db, oldVersion, newVersion) async {
        if (oldVersion < 2) {
          await db.execute('''CREATE TABLE settings(
              id INTEGER PRIMARY KEY,
              goal REAL)''');
        }
      },
    );
  }

  Future<int> insertWeight(WeightEntry entry) async {
    final database = await db;
    return await database.insert('weights', entry.toMap());
  }

  Future<List<WeightEntry>> getWeights() async {
    final database = await db;
    final result = await database.query('weights', orderBy: 'date ASC');
    return result
        .map((row) => WeightEntry(
              id: row['id'] as int,
              weight: row['weight'] as double,
              date: row['date'] as String,
            ))
        .toList();
  }

  Future<void> setGoal(double goal) async {
    final database = await db;
    await database.insert('settings', {'id': 1, 'goal': goal},
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<double?> getGoal() async {
    final database = await db;
    final result = await database.query('settings', where: 'id = ?', whereArgs: [1]);
    if (result.isNotEmpty) {
      return result.first['goal'] as double;
    }
    return null;
  }
}

class WeightTrackerApp extends StatefulWidget {
  @override
  _WeightTrackerAppState createState() => _WeightTrackerAppState();
}

class _WeightTrackerAppState extends State<WeightTrackerApp> {
  final DatabaseHelper dbHelper = DatabaseHelper.instance;
  List<WeightEntry> weights = [];
  double? goalWeight;

  final FlutterLocalNotificationsPlugin notificationsPlugin =
      FlutterLocalNotificationsPlugin();

  @override
  void initState() {
    super.initState();
    _loadWeights();
    _loadGoal();
    _initNotifications();
    _scheduleDailyReminder();
  }

  Future<void> _initNotifications() async {
    const AndroidInitializationSettings initSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');

    const InitializationSettings initSettings =
        InitializationSettings(android: initSettingsAndroid);

    await notificationsPlugin.initialize(initSettings);
  }

  Future<void> _scheduleDailyReminder() async {
    const AndroidNotificationDetails androidDetails = AndroidNotificationDetails(
      'daily_reminder',
      'Daily Reminder',
      channelDescription: 'Reminds user to log their daily weight',
      importance: Importance.max,
      priority: Priority.high,
    );

    const NotificationDetails platformDetails =
        NotificationDetails(android: androidDetails);

    await notificationsPlugin.periodicallyShow(
      0,
      'Log your weight',
      'Don\'t forget to enter today\'s weight!',
      RepeatInterval.daily,
      platformDetails,
      androidAllowWhileIdle: true,
    );
  }

  Future<void> _loadWeights() async {
    final data = await dbHelper.getWeights();
    setState(() => weights = data);
  }

  Future<void> _loadGoal() async {
    final goal = await dbHelper.getGoal();
    setState(() => goalWeight = goal);
  }

  void _addWeight() async {
    final controller = TextEditingController();
    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Add Weight'),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(labelText: 'Enter weight (kg)'),
        ),
        actions: [
          TextButton(
            onPressed: () async {
              if (controller.text.isNotEmpty) {
                final entry = WeightEntry(
                  weight: double.parse(controller.text),
                  date: DateTime.now().toIso8601String(),
                );
                await dbHelper.insertWeight(entry);
                Navigator.pop(context);
                _loadWeights();
              }
            },
            child: Text('Save'),
          ),
        ],
      ),
    );
  }

  void _setGoal() async {
    final controller = TextEditingController();
    await showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Set Goal Weight'),
        content: TextField(
          controller: controller,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(labelText: 'Enter goal weight (kg)'),
        ),
        actions: [
          TextButton(
            onPressed: () async {
              if (controller.text.isNotEmpty) {
                await dbHelper.setGoal(double.parse(controller.text));
                Navigator.pop(context);
                _loadGoal();
              }
            },
            child: Text('Save'),
          ),
        ],
      ),
    );
  }

  Widget _buildChart() {
    if (weights.isEmpty) {
      return Center(child: Text('No data for chart'));
    }

    List<FlSpot> spots = [];
    for (int i = 0; i < weights.length; i++) {
      spots.add(FlSpot(i.toDouble(), weights[i].weight));
    }

    List<HorizontalLine> goalLine = [];
    if (goalWeight != null) {
      goalLine.add(HorizontalLine(
        y: goalWeight!,
        color: Colors.red,
        strokeWidth: 2,
        dashArray: [5, 5],
        label: HorizontalLineLabel(
          show: true,
          alignment: Alignment.topLeft,
          style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold),
          labelResolver: (_) => 'Goal: ${goalWeight!.toStringAsFixed(1)} kg',
        ),
      ));
    }

    return LineChart(
      LineChartData(
        gridData: FlGridData(show: true),
        titlesData: FlTitlesData(
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              getTitlesWidget: (value, meta) {
                if (value.toInt() % 2 == 0 && value.toInt() < weights.length) {
                  return Text(weights[value.toInt()].date.substring(5, 10),
                      style: TextStyle(fontSize: 10));
                }
                return Container();
              },
            ),
          ),
          leftTitles: AxisTitles(
            sideTitles: SideTitles(showTitles: true),
          ),
        ),
        borderData: FlBorderData(show: true),
        lineBarsData: [
          LineChartBarData(
            spots: spots,
            isCurved: true,
            color: Colors.blue,
            dotData: FlDotData(show: true),
          ),
        ],
        extraLinesData: ExtraLinesData(horizontalLines: goalLine),
      ),
    );
  }

  Widget _buildProgressBar() {
    if (weights.isEmpty || goalWeight == null) {
      return Container();
    }
    double currentWeight = weights.last.weight;
    double progress = (goalWeight! - currentWeight).abs() /
        (weights.first.weight - goalWeight!).abs();
    progress = progress.clamp(0.0, 1.0);

    return Column(
      children: [
        Text(
          'Progress toward goal: ${(progress * 100).toStringAsFixed(1)}%',
          style: TextStyle(fontWeight: FontWeight.bold),
        ),
        LinearProgressIndicator(
          value: progress,
          backgroundColor: Colors.grey[300],
          color: Colors.green,
          minHeight: 10,
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text('Weight Tracker'),
          actions: [
            IconButton(
              icon: Icon(Icons.flag),
              onPressed: _setGoal,
            )
          ],
        ),
        body: Column(
          children: [
            Expanded(
              flex: 2,
              child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: _buildChart(),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(8.0),
              child: _buildProgressBar(),
            ),
            Expanded(
              flex: 3,
              child: weights.isEmpty
                  ? Center(child: Text('No entries yet'))
                  : ListView.builder(
                      itemCount: weights.length,
                      itemBuilder: (context, index) {
                        final entry = weights[index];
                        return ListTile(
                          title: Text('${entry.weight} kg'),
                          subtitle: Text(entry.date.substring(0, 10)),
                        );
                      },
                    ),
            ),
          ],
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: _addWeight,
          child: Icon(Icons.add),
        ),
      ),
    );
  }
}
